using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Domain.Authorization.Constants;

namespace Domain.CodeGenerator.Generators;

sealed class RoleIdsGenerator : ICodeGenerationTask
{
    private static readonly HashSet<string> ReservedKeywords = new(StringComparer.Ordinal)
    {
        "abstract","as","base","bool","break","byte","case","catch","char","checked","class","const","continue","decimal","default","delegate","do","double","else","enum","event","explicit","extern","false","finally","fixed","float","for","foreach","goto","if","implicit","in","int","interface","internal","is","lock","long","namespace","new","null","object","operator","out","override","params","private","protected","public","readonly","ref","return","sbyte","sealed","short","sizeof","stackalloc","static","string","struct","switch","this","throw","true","try","typeof","uint","ulong","unchecked","unsafe","ushort","using","virtual","void","volatile","while"
    };

    public string Id => "RoleIds";

    public string GetDefaultOutputPath(string applicationBaseDirectory) =>
        Path.Combine(applicationBaseDirectory, "..", "..", "..", "Domain", "Authorization", "Constants", "RoleIds.Generated.cs");

    public async Task GenerateAsync(CodeGenerationContext context, CancellationToken cancellationToken)
    {
        var outputPath = context.GetOutputPath(Id);
        var outputDirectory = Path.GetDirectoryName(outputPath);
        if (string.IsNullOrWhiteSpace(outputDirectory))
        {
            throw new InvalidOperationException("Failed to resolve output directory for role identifiers file.");
        }

        Directory.CreateDirectory(outputDirectory);

        var builder = new StringBuilder();
        AppendHeader(builder, context.UtcNow);

        var roles = Roles.All
            .OrderBy(role => role.Code, StringComparer.Ordinal)
            .ToArray();

        WriteAllCodes(builder, roles);

        foreach (var role in roles)
        {
            WriteRole(builder, role);
        }

        builder.AppendLine("}");

        var contents = builder.ToString();
        await File.WriteAllTextAsync(outputPath, contents, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false), cancellationToken);
    }

    private static void AppendHeader(StringBuilder builder, DateTime utcNow)
    {
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("// Generated by Domain.CodeGenerator. Do not edit manually.");
        builder.AppendLine($"// Generated on {utcNow:O} UTC");
        builder.AppendLine();
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine();
        builder.AppendLine("namespace Domain.Authorization.Constants;");
        builder.AppendLine();
        builder.AppendLine("public static class RoleIds");
        builder.AppendLine("{");
    }

    private static void WriteAllCodes(StringBuilder builder, IReadOnlyCollection<RoleDefinition> roles)
    {
        builder.AppendLine("    /// <summary>All known role codes.</summary>");
        builder.AppendLine("    public static IReadOnlyCollection<string> AllCodes { get; } = new string[]");
        builder.AppendLine("    {");
        foreach (var code in roles.Select(role => role.Code).OrderBy(code => code, StringComparer.Ordinal))
        {
            builder.AppendLine($"        \"{EscapeForString(code)}\",");
        }

        builder.AppendLine("    };");
        builder.AppendLine();
    }

    private static void WriteRole(StringBuilder builder, RoleDefinition role)
    {
        var className = ToIdentifier(role.Code);
        builder.AppendLine($"    /// <summary>Identifiers and parameters for the '{EscapeForXml(role.Name)}' role.</summary>");
        builder.AppendLine($"    public static class {className}");
        builder.AppendLine("    {");
        builder.AppendLine($"        /// <summary>Role code for '{EscapeForXml(role.Name)}'.</summary>");
        builder.AppendLine($"        public const string Code = \"{EscapeForString(role.Code)}\";");

        var parameters = role.TemplateParameters
            .Distinct(StringComparer.Ordinal)
            .OrderBy(parameter => parameter, StringComparer.Ordinal)
            .ToArray();

        if (parameters.Length > 0)
        {
            builder.AppendLine();
            builder.AppendLine("        /// <summary>All template parameters consumed by this role's permission templates.</summary>");
            builder.AppendLine("        public static IReadOnlyCollection<string> Parameters { get; } = new string[]");
            builder.AppendLine("        {");
            foreach (var parameter in parameters)
            {
                builder.AppendLine($"            \"{EscapeForString(parameter)}\",");
            }

            builder.AppendLine("        };");

            var usedConstNames = new HashSet<string>(StringComparer.Ordinal);
            foreach (var parameter in parameters)
            {
                var constName = DetermineParameterConstName(parameter, usedConstNames);
                builder.AppendLine();
                builder.AppendLine($"        /// <summary>Parameter identifier '{EscapeForXml(parameter)}'.</summary>");
                builder.AppendLine($"        public const string {constName} = \"{EscapeForString(parameter)}\";");
            }
        }

        builder.AppendLine("    }");
        builder.AppendLine();
    }

    private static string DetermineParameterConstName(string parameter, HashSet<string> usedNames)
    {
        var baseName = ToParameterIdentifier(parameter) + "Parameter";
        if (usedNames.Add(baseName))
        {
            return baseName;
        }

        var suffix = 2;
        while (true)
        {
            var candidate = baseName + suffix.ToString(CultureInfo.InvariantCulture);
            if (usedNames.Add(candidate))
            {
                return candidate;
            }

            suffix++;
        }
    }

    private static string ToParameterIdentifier(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return "Parameter";
        }

        var normalized = NormalizeParameterValue(value);
        return ToIdentifier(normalized);
    }

    private static string ToIdentifier(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return "Value";
        }

        var parts = value.Split(['_', '-', '.'], StringSplitOptions.RemoveEmptyEntries);
        var textInfo = CultureInfo.InvariantCulture.TextInfo;
        var candidate = string.Concat(parts.Select(part => textInfo.ToTitleCase(part.ToLowerInvariant())));

        if (candidate.Length == 0)
        {
            candidate = "Value";
        }

        if (char.IsDigit(candidate[0]))
        {
            candidate = "_" + candidate;
        }

        if (ReservedKeywords.Contains(candidate))
        {
            candidate = "@" + candidate;
        }

        return candidate;
    }

    private static string NormalizeParameterValue(string value)
    {
        if (value.IndexOfAny(['_', '-', '.']) >= 0)
        {
            return value;
        }

        var builder = new StringBuilder(value.Length * 2);

        for (var index = 0; index < value.Length; index++)
        {
            var current = value[index];
            if (index > 0 && char.IsUpper(current) && (char.IsLower(value[index - 1]) || char.IsDigit(value[index - 1])))
            {
                builder.Append('_');
            }

            builder.Append(current);
        }

        return builder.ToString();
    }

    private static string EscapeForString(string value) => value
        .Replace("\\", "\\\\")
        .Replace("\"", "\\\"");

    private static string EscapeForXml(string value) => SecurityElement.Escape(value) ?? value;
}
