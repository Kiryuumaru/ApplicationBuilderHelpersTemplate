using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Domain.Authorization.Constants;
using Domain.Authorization.Enums;
using Domain.Authorization.Models;
using Domain.Authorization.ValueObjects;

namespace Domain.CodeGenerator.Generators;

sealed class PermissionIdsGenerator : ICodeGenerationTask
{
    private static readonly HashSet<string> ReservedKeywords = new(StringComparer.Ordinal)
    {
        "abstract","as","base","bool","break","byte","case","catch","char","checked","class","const","continue","decimal","default","delegate","do","double","else","enum","event","explicit","extern","false","finally","fixed","float","for","foreach","goto","if","implicit","in","int","interface","internal","is","lock","long","namespace","new","null","object","operator","out","override","params","private","protected","public","readonly","ref","return","sbyte","sealed","short","sizeof","stackalloc","static","string","struct","switch","this","throw","true","try","typeof","uint","ulong","unchecked","unsafe","ushort","using","virtual","void","volatile","while"
    };

    public string Id => "PermissionIds";

    public string GetDefaultOutputPath(string applicationBaseDirectory) =>
        Path.Combine(applicationBaseDirectory, "..", "..", "..", "Domain", "Authorization", "Constants", "PermissionIds.Generated.cs");

    public async Task GenerateAsync(CodeGenerationContext context, CancellationToken cancellationToken)
    {
        var outputPath = context.GetOutputPath(Id);
        var outputDirectory = Path.GetDirectoryName(outputPath);

        if (string.IsNullOrWhiteSpace(outputDirectory))
        {
            throw new InvalidOperationException("Failed to resolve output directory for permission identifiers file.");
        }

        Directory.CreateDirectory(outputDirectory);

        var builder = new StringBuilder();
        var allPermissions = Permissions.GetAll();

        AppendHeader(builder, context.UtcNow);
        WriteAllPermissionPaths(builder, allPermissions);
        builder.AppendLine();
        WriteAllParameters(builder, allPermissions);
        builder.AppendLine();
        WriteGlobalScopes(builder);
        builder.AppendLine();

        foreach (var root in Permissions.PermissionTreeRoots)
        {
            WritePermissionNode(builder, root, 1, Array.Empty<string>(), false, false);
        }

        builder.AppendLine("}");
        builder.AppendLine();

        // Write PermissionMetadata class
        WritePermissionMetadata(builder, allPermissions);

        var contents = builder.ToString();
        await File.WriteAllTextAsync(outputPath, contents, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false), cancellationToken);
    }

    private static void AppendHeader(StringBuilder builder, DateTime utcNow)
    {
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("// Generated by Domain.CodeGenerator. Do not edit manually.");
        builder.AppendLine($"// Generated on {utcNow:O} UTC");
        builder.AppendLine();
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using Domain.Authorization.ValueObjects;");
        builder.AppendLine();
        builder.AppendLine("namespace Domain.Authorization.Constants;");
        builder.AppendLine();
        builder.AppendLine("public static class PermissionIds");
        builder.AppendLine("{");
    }

    private static void WriteAllPermissionPaths(StringBuilder builder, IReadOnlyCollection<Permission> permissions)
    {
        builder.AppendLine("    /// <summary>");
        builder.AppendLine("    /// Flat list of all valid permission paths.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    public static IReadOnlyCollection<string> All { get; } = new string[]");
        builder.AppendLine("    {");

        var distinctPaths = permissions
            .Where(permission => permission.AccessCategory != PermissionAccessCategory.Unspecified)
            .Select(permission => permission.Path)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(path => path, StringComparer.Ordinal);

        foreach (var path in distinctPaths)
        {
            builder.AppendLine($"        \"{EscapeForString(path)}\",");
        }

        builder.AppendLine("    };");
    }

    private static void WriteAllParameters(StringBuilder builder, IReadOnlyCollection<Permission> permissions)
    {
        var allParameters = permissions
            .SelectMany(p => p.Parameters)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(p => p, StringComparer.Ordinal)
            .ToList();

        builder.AppendLine("    /// <summary>");
        builder.AppendLine("    /// Flat list of all unique parameter names used in permissions.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    public static IReadOnlyCollection<string> AllParameters { get; } = new string[]");
        builder.AppendLine("    {");

        foreach (var param in allParameters)
        {
            builder.AppendLine($"        \"{EscapeForString(param)}\",");
        }

        builder.AppendLine("    };");
    }

    private static void WriteGlobalScopes(StringBuilder builder)
    {
        builder.AppendLine("    /// <summary>");
        builder.AppendLine("    /// Global permission scope identifiers covering the entire platform.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    public static class Global");
        builder.AppendLine("    {");

        // Global Read scope
        builder.AppendLine("        /// <summary>Global read scope covering every feature.</summary>");
        builder.AppendLine("        public static class Read");
        builder.AppendLine("        {");
        builder.AppendLine($"            private const string Path = \"{EscapeForString(Permissions.RootReadIdentifier)}\";");
        builder.AppendLine();
        builder.AppendLine("            /// <summary>Creates an allow directive for global read access.</summary>");
        builder.AppendLine($"            public static string Allow() => \"allow;{EscapeForString(Permissions.RootReadIdentifier)}\";");
        builder.AppendLine();
        builder.AppendLine("            /// <summary>Creates a deny directive for global read access.</summary>");
        builder.AppendLine($"            public static string Deny() => \"deny;{EscapeForString(Permissions.RootReadIdentifier)}\";");
        builder.AppendLine();
        builder.AppendLine("            /// <summary>Creates a scope builder with the userId parameter.</summary>");
        builder.AppendLine("            public static ScopeBuilder WithUserId(string value) => new ScopeBuilder(Path, \"userId\", value);");
        builder.AppendLine();
        WriteScopeBuilderStruct(builder, 3, [("userId", "UserId")]);
        builder.AppendLine("        }");

        builder.AppendLine();

        // Global Write scope
        builder.AppendLine("        /// <summary>Global write scope covering every feature.</summary>");
        builder.AppendLine("        public static class Write");
        builder.AppendLine("        {");
        builder.AppendLine($"            private const string Path = \"{EscapeForString(Permissions.RootWriteIdentifier)}\";");
        builder.AppendLine();
        builder.AppendLine("            /// <summary>Creates an allow directive for global write access.</summary>");
        builder.AppendLine($"            public static string Allow() => \"allow;{EscapeForString(Permissions.RootWriteIdentifier)}\";");
        builder.AppendLine();
        builder.AppendLine("            /// <summary>Creates a deny directive for global write access.</summary>");
        builder.AppendLine($"            public static string Deny() => \"deny;{EscapeForString(Permissions.RootWriteIdentifier)}\";");
        builder.AppendLine();
        builder.AppendLine("            /// <summary>Creates a scope builder with the userId parameter.</summary>");
        builder.AppendLine("            public static ScopeBuilder WithUserId(string value) => new ScopeBuilder(Path, \"userId\", value);");
        builder.AppendLine();
        WriteScopeBuilderStruct(builder, 3, [("userId", "UserId")]);
        builder.AppendLine("        }");

        builder.AppendLine("    }");
    }

    private static void WritePermissionMetadata(StringBuilder builder, IReadOnlyCollection<Permission> permissions)
    {
        var rLeafs = permissions
            .Where(p => !p.HasChildren && p.AccessCategory == PermissionAccessCategory.Read)
            .Select(p => p.Path)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(p => p, StringComparer.Ordinal)
            .ToList();

        var wLeafs = permissions
            .Where(p => !p.HasChildren && p.AccessCategory == PermissionAccessCategory.Write)
            .Select(p => p.Path)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(p => p, StringComparer.Ordinal)
            .ToList();

        builder.AppendLine("/// <summary>");
        builder.AppendLine("/// Metadata about permission categories for scope evaluation.");
        builder.AppendLine("/// </summary>");
        builder.AppendLine("public static class PermissionMetadata");
        builder.AppendLine("{");

        builder.AppendLine("    /// <summary>");
        builder.AppendLine("    /// Collection of all Read leaf permission paths (RLeaf).");
        builder.AppendLine("    /// These are granted by parent _read scopes.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    public static IReadOnlyCollection<string> RLeafPermissions { get; } = new string[]");
        builder.AppendLine("    {");
        foreach (var path in rLeafs)
        {
            builder.AppendLine($"        \"{EscapeForString(path)}\",");
        }
        builder.AppendLine("    };");

        builder.AppendLine();

        builder.AppendLine("    /// <summary>");
        builder.AppendLine("    /// Collection of all Write leaf permission paths (WLeaf).");
        builder.AppendLine("    /// These are granted by parent _write scopes.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    public static IReadOnlyCollection<string> WLeafPermissions { get; } = new string[]");
        builder.AppendLine("    {");
        foreach (var path in wLeafs)
        {
            builder.AppendLine($"        \"{EscapeForString(path)}\",");
        }
        builder.AppendLine("    };");

        builder.AppendLine("}");
    }

    private static void WritePermissionNode(StringBuilder builder, Permission permission, int indentLevel, IReadOnlyList<string> inheritedParameters, bool parentHasReadScope, bool parentHasWriteScope)
    {
        var indent = new string(' ', indentLevel * 4);
        var rawClassName = ToIdentifier(permission.Identifier);

        // Handle naming conflicts: if parent has Read scope and this permission is "read", rename to "ReadPermission"
        var className = rawClassName;
        if (parentHasReadScope && string.Equals(rawClassName, "Read", StringComparison.Ordinal))
        {
            className = "ReadPermission";
        }
        else if (parentHasWriteScope && string.Equals(rawClassName, "Write", StringComparison.Ordinal))
        {
            className = "WritePermission";
        }

        builder.AppendLine();
        builder.AppendLine($"{indent}/// <summary>{EscapeForXml(permission.Description)}</summary>");
        builder.AppendLine($"{indent}public static class {className}");
        builder.AppendLine($"{indent}{{");

        var combinedParameters = CombineParameters(inheritedParameters, permission.Parameters);
        var parameterMethods = combinedParameters
            .Select(p => (Parameter: p, MethodName: "With" + ToParameterIdentifier(p)))
            .ToList();

        // Write parameter constants for discoverability
        if (combinedParameters.Count > 0)
        {
            var parameterConstantNames = new HashSet<string>(StringComparer.Ordinal);
            foreach (var parameter in combinedParameters)
            {
                var constName = DetermineParameterConstName(parameter, parameterConstantNames);
                builder.AppendLine($"{indent}    /// <summary>Template parameter '{EscapeForXml(parameter)}' used when scoping this permission.</summary>");
                builder.AppendLine($"{indent}    public const string {constName} = \"{EscapeForString(parameter)}\";");
            }
            builder.AppendLine();
        }

        var orderedChildren = permission.Permissions
            .OrderBy(child => child.Identifier, StringComparer.Ordinal)
            .ToList();

        Permission? readChild = null;
        Permission? writeChild = null;

        // Track whether we have _read/_write scopes to avoid naming conflicts
        var hasReadScope = false;
        var hasWriteScope = false;

        for (var index = orderedChildren.Count - 1; index >= 0; index--)
        {
            var child = orderedChildren[index];
            if (string.Equals(child.Identifier, "_read", StringComparison.Ordinal))
            {
                readChild = child;
                hasReadScope = true;
                orderedChildren.RemoveAt(index);
            }
            else if (string.Equals(child.Identifier, "_write", StringComparison.Ordinal))
            {
                writeChild = child;
                hasWriteScope = true;
                orderedChildren.RemoveAt(index);
            }
        }

        // Write Read scope class if present
        if (readChild is not null)
        {
            WriteScopeClass(builder, indentLevel + 1, "Read", readChild.Path, readChild.Description, parameterMethods);
        }

        // Write Write scope class if present
        if (writeChild is not null)
        {
            WriteScopeClass(builder, indentLevel + 1, "Write", writeChild.Path, writeChild.Description, parameterMethods);
        }

        // Write leaf permission class (for non-node permissions)
        var isLeaf = !permission.HasChildren;
        if (isLeaf && permission.AccessCategory != PermissionAccessCategory.Unspecified)
        {
            // This is a leaf permission - write Allow/Deny methods directly
            builder.AppendLine($"{indent}    private const string Path = \"{EscapeForString(permission.Path)}\";");
            builder.AppendLine();
            builder.AppendLine($"{indent}    /// <summary>Creates an allow directive for this permission.</summary>");
            builder.AppendLine($"{indent}    public static string Allow() => \"allow;{EscapeForString(permission.Path)}\";");
            builder.AppendLine();
            builder.AppendLine($"{indent}    /// <summary>Creates a deny directive for this permission.</summary>");
            builder.AppendLine($"{indent}    public static string Deny() => \"deny;{EscapeForString(permission.Path)}\";");

            if (parameterMethods.Count > 0)
            {
                builder.AppendLine();
                foreach (var (parameter, methodName) in parameterMethods)
                {
                    builder.AppendLine($"{indent}    /// <summary>Creates a scope builder with the '{EscapeForXml(parameter)}' parameter.</summary>");
                    builder.AppendLine($"{indent}    public static ScopeBuilder {methodName}(string value) => new ScopeBuilder(Path, \"{EscapeForString(parameter)}\", value);");
                }

                builder.AppendLine();
                WriteScopeBuilderStruct(builder, indentLevel + 1, parameterMethods);

                // Permission Request API: Permission property returning builder with With*() methods
                builder.AppendLine();
                builder.AppendLine($"{indent}    /// <summary>Creates a permission request builder for HasPermission calls.</summary>");
                builder.AppendLine($"{indent}    public static PermissionRequestBuilder Permission => new PermissionRequestBuilder(Path);");

                builder.AppendLine();
                WritePermissionRequestBuilderStruct(builder, indentLevel + 1, parameterMethods);
            }
            else
            {
                // No parameters - just provide a simple Permission property
                builder.AppendLine();
                builder.AppendLine($"{indent}    /// <summary>Creates a permission request for HasPermission calls.</summary>");
                builder.AppendLine($"{indent}    public static PermissionRequest Permission => new PermissionRequest(Path);");
            }
        }

        // Write child nodes
        foreach (var branch in orderedChildren.Where(child => child.HasChildren))
        {
            WritePermissionNode(builder, branch, indentLevel + 1, combinedParameters, hasReadScope, hasWriteScope);
        }

        foreach (var leaf in orderedChildren.Where(child => !child.HasChildren))
        {
            WritePermissionNode(builder, leaf, indentLevel + 1, combinedParameters, hasReadScope, hasWriteScope);
        }

        builder.AppendLine($"{indent}}}");
    }

    private static void WriteScopeClass(
        StringBuilder builder,
        int indentLevel,
        string className,
        string path,
        string description,
        List<(string Parameter, string MethodName)> parameterMethods)
    {
        var indent = new string(' ', indentLevel * 4);

        builder.AppendLine();
        builder.AppendLine($"{indent}/// <summary>{EscapeForXml(description)}</summary>");
        builder.AppendLine($"{indent}public static class {className}");
        builder.AppendLine($"{indent}{{");
        builder.AppendLine($"{indent}    private const string Path = \"{EscapeForString(path)}\";");
        builder.AppendLine();
        builder.AppendLine($"{indent}    /// <summary>Creates an allow directive for this scope.</summary>");
        builder.AppendLine($"{indent}    public static string Allow() => \"allow;{EscapeForString(path)}\";");
        builder.AppendLine();
        builder.AppendLine($"{indent}    /// <summary>Creates a deny directive for this scope.</summary>");
        builder.AppendLine($"{indent}    public static string Deny() => \"deny;{EscapeForString(path)}\";");

        if (parameterMethods.Count > 0)
        {
            builder.AppendLine();
            foreach (var (parameter, methodName) in parameterMethods)
            {
                builder.AppendLine($"{indent}    /// <summary>Creates a scope builder with the '{EscapeForXml(parameter)}' parameter.</summary>");
                builder.AppendLine($"{indent}    public static ScopeBuilder {methodName}(string value) => new ScopeBuilder(Path, \"{EscapeForString(parameter)}\", value);");
            }

            builder.AppendLine();
            WriteScopeBuilderStruct(builder, indentLevel + 1, parameterMethods);
        }

        builder.AppendLine($"{indent}}}");
    }

    private static void WriteScopeBuilderStruct(
        StringBuilder builder,
        int indentLevel,
        List<(string Parameter, string MethodName)> parameterMethods)
    {
        var indent = new string(' ', indentLevel * 4);

        builder.AppendLine($"{indent}/// <summary>Immutable builder for constructing scoped directives with parameters.</summary>");
        builder.AppendLine($"{indent}public readonly struct ScopeBuilder");
        builder.AppendLine($"{indent}{{");
        builder.AppendLine($"{indent}    private readonly string _path;");
        builder.AppendLine($"{indent}    private readonly string _params;");
        builder.AppendLine();
        builder.AppendLine($"{indent}    internal ScopeBuilder(string path, string key, string value)");
        builder.AppendLine($"{indent}    {{");
        builder.AppendLine($"{indent}        _path = path;");
        builder.AppendLine($"{indent}        _params = $\"{{key}}={{value}}\";");
        builder.AppendLine($"{indent}    }}");
        builder.AppendLine();
        builder.AppendLine($"{indent}    private ScopeBuilder(string path, string existingParams, string key, string value)");
        builder.AppendLine($"{indent}    {{");
        builder.AppendLine($"{indent}        _path = path;");
        builder.AppendLine($"{indent}        _params = $\"{{existingParams}};{{key}}={{value}}\";");
        builder.AppendLine($"{indent}    }}");

        foreach (var (parameter, methodName) in parameterMethods)
        {
            builder.AppendLine();
            builder.AppendLine($"{indent}    /// <summary>Adds the '{EscapeForXml(parameter)}' parameter to this builder.</summary>");
            builder.AppendLine($"{indent}    public ScopeBuilder {methodName}(string value) =>");
            builder.AppendLine($"{indent}        new ScopeBuilder(_path, _params, \"{EscapeForString(parameter)}\", value);");
        }

        builder.AppendLine();
        builder.AppendLine($"{indent}    /// <summary>Creates an allow directive with the configured parameters.</summary>");
        builder.AppendLine($"{indent}    public string Allow() => string.IsNullOrEmpty(_params)");
        builder.AppendLine($"{indent}        ? $\"allow;{{_path}}\"");
        builder.AppendLine($"{indent}        : $\"allow;{{_path}};{{_params}}\";");
        builder.AppendLine();
        builder.AppendLine($"{indent}    /// <summary>Creates a deny directive with the configured parameters.</summary>");
        builder.AppendLine($"{indent}    public string Deny() => string.IsNullOrEmpty(_params)");
        builder.AppendLine($"{indent}        ? $\"deny;{{_path}}\"");
        builder.AppendLine($"{indent}        : $\"deny;{{_path}};{{_params}}\";");

        builder.AppendLine($"{indent}}}");
    }

    private static void WritePermissionRequestBuilderStruct(
        StringBuilder builder,
        int indentLevel,
        List<(string Parameter, string MethodName)> parameterMethods)
    {
        var indent = new string(' ', indentLevel * 4);

        builder.AppendLine($"{indent}/// <summary>Immutable builder for constructing permission requests with parameters.</summary>");
        builder.AppendLine($"{indent}public readonly struct PermissionRequestBuilder");
        builder.AppendLine($"{indent}{{");
        builder.AppendLine($"{indent}    private readonly string _path;");
        builder.AppendLine($"{indent}    private readonly string? _params;");
        builder.AppendLine();
        builder.AppendLine($"{indent}    internal PermissionRequestBuilder(string path)");
        builder.AppendLine($"{indent}    {{");
        builder.AppendLine($"{indent}        _path = path;");
        builder.AppendLine($"{indent}        _params = null;");
        builder.AppendLine($"{indent}    }}");
        builder.AppendLine();
        builder.AppendLine($"{indent}    private PermissionRequestBuilder(string path, string key, string value)");
        builder.AppendLine($"{indent}    {{");
        builder.AppendLine($"{indent}        _path = path;");
        builder.AppendLine($"{indent}        _params = $\"{{key}}={{value}}\";");
        builder.AppendLine($"{indent}    }}");
        builder.AppendLine();
        builder.AppendLine($"{indent}    private PermissionRequestBuilder(string path, string existingParams, string key, string value)");
        builder.AppendLine($"{indent}    {{");
        builder.AppendLine($"{indent}        _path = path;");
        builder.AppendLine($"{indent}        _params = $\"{{existingParams}};{{key}}={{value}}\";");
        builder.AppendLine($"{indent}    }}");

        foreach (var (parameter, methodName) in parameterMethods)
        {
            builder.AppendLine();
            builder.AppendLine($"{indent}    /// <summary>Adds the '{EscapeForXml(parameter)}' parameter to this permission request.</summary>");
            builder.AppendLine($"{indent}    public PermissionRequestBuilder {methodName}(string value) =>");
            builder.AppendLine($"{indent}        string.IsNullOrEmpty(_params)");
            builder.AppendLine($"{indent}            ? new PermissionRequestBuilder(_path, \"{EscapeForString(parameter)}\", value)");
            builder.AppendLine($"{indent}            : new PermissionRequestBuilder(_path, _params, \"{EscapeForString(parameter)}\", value);");
        }

        builder.AppendLine();
        builder.AppendLine($"{indent}    /// <summary>Converts this builder to its string representation for HasPermission calls.</summary>");
        builder.AppendLine($"{indent}    public override string ToString() =>");
        builder.AppendLine($"{indent}        string.IsNullOrEmpty(_params) ? _path : $\"{{_path}};{{_params}}\";");
        builder.AppendLine();
        builder.AppendLine($"{indent}    /// <summary>Implicit conversion to string for seamless use with HasPermission methods.</summary>");
        builder.AppendLine($"{indent}    public static implicit operator string(PermissionRequestBuilder builder) => builder.ToString();");

        builder.AppendLine($"{indent}}}");
    }

    private static string DetermineParameterConstName(string parameter, HashSet<string> usedNames)
    {
        var baseName = ToParameterIdentifier(parameter) + "Parameter";

        if (usedNames.Add(baseName))
        {
            return baseName;
        }

        var suffix = 2;
        while (true)
        {
            var candidate = baseName + suffix.ToString(CultureInfo.InvariantCulture);
            if (usedNames.Add(candidate))
            {
                return candidate;
            }

            suffix++;
        }
    }

    private static IReadOnlyList<string> CombineParameters(IReadOnlyCollection<string> inherited, IReadOnlyCollection<string> current)
    {
        if (inherited.Count == 0 && current.Count == 0)
        {
            return Array.Empty<string>();
        }

        var result = new List<string>(inherited.Count + current.Count);
        var seen = new HashSet<string>(StringComparer.Ordinal);

        foreach (var parameter in inherited)
        {
            if (seen.Add(parameter))
            {
                result.Add(parameter);
            }
        }

        foreach (var parameter in current)
        {
            if (seen.Add(parameter))
            {
                result.Add(parameter);
            }
        }

        return result;
    }

    private static string ToIdentifier(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return "Value";
        }

        var parts = value.Split(['_', '-', '.'], StringSplitOptions.RemoveEmptyEntries);
        var textInfo = CultureInfo.InvariantCulture.TextInfo;
        var candidate = string.Concat(parts.Select(part => textInfo.ToTitleCase(part.ToLowerInvariant())));

        if (candidate.Length == 0)
        {
            candidate = "Value";
        }

        if (char.IsDigit(candidate[0]))
        {
            candidate = "_" + candidate;
        }

        if (ReservedKeywords.Contains(candidate))
        {
            candidate = "@" + candidate;
        }

        return candidate;
    }

    private static string ToParameterIdentifier(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return "Parameter";
        }

        var normalized = NormalizeParameterValue(value);
        return ToIdentifier(normalized);
    }

    private static string NormalizeParameterValue(string value)
    {
        if (value.IndexOfAny(['_', '-', '.']) >= 0)
        {
            return value;
        }

        var builder = new StringBuilder(value.Length * 2);

        for (var index = 0; index < value.Length; index++)
        {
            var current = value[index];
            if (index > 0 && char.IsUpper(current) && (char.IsLower(value[index - 1]) || char.IsDigit(value[index - 1])))
            {
                builder.Append('_');
            }
            builder.Append(current);
        }

        return builder.ToString();
    }

    private static string EscapeForString(string value) => value
        .Replace("\\", "\\\\")
        .Replace("\"", "\\\"");

    private static string EscapeForXml(string value) => SecurityElement.Escape(value) ?? value;
}
