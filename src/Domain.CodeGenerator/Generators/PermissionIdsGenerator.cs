using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Domain.Authorization.Constants;
using Domain.Authorization.Enums;
using Domain.Authorization.Models;

namespace Domain.CodeGenerator.Generators;

sealed class PermissionIdsGenerator : ICodeGenerationTask
{
    private static readonly HashSet<string> ReservedKeywords = new(StringComparer.Ordinal)
    {
        "abstract","as","base","bool","break","byte","case","catch","char","checked","class","const","continue","decimal","default","delegate","do","double","else","enum","event","explicit","extern","false","finally","fixed","float","for","foreach","goto","if","implicit","in","int","interface","internal","is","lock","long","namespace","new","null","object","operator","out","override","params","private","protected","public","readonly","ref","return","sbyte","sealed","short","sizeof","stackalloc","static","string","struct","switch","this","throw","true","try","typeof","uint","ulong","unchecked","unsafe","ushort","using","virtual","void","volatile","while"
    };

    public string Id => "PermissionIds";

    public string GetDefaultOutputPath(string applicationBaseDirectory) =>
        Path.Combine(applicationBaseDirectory, "..", "..", "..", "Domain", "Authorization", "Constants", "PermissionIds.Generated.cs");

    public async Task GenerateAsync(CodeGenerationContext context, CancellationToken cancellationToken)
    {
        var outputPath = context.GetOutputPath(Id);
        var outputDirectory = Path.GetDirectoryName(outputPath);

        if (string.IsNullOrWhiteSpace(outputDirectory))
        {
            throw new InvalidOperationException("Failed to resolve output directory for permission identifiers file.");
        }

        Directory.CreateDirectory(outputDirectory);

        var builder = new StringBuilder();

        AppendHeader(builder, context.UtcNow);
        WriteAllPermissionPaths(builder, Permissions.GetAll());
        builder.AppendLine();
        WriteGlobalScopes(builder);
        builder.AppendLine();

        foreach (var root in Permissions.PermissionTreeRoots)
        {
            WritePermissionNode(builder, root, 1, Array.Empty<string>());
        }

        builder.AppendLine("}");

        var contents = builder.ToString();
        await File.WriteAllTextAsync(outputPath, contents, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false), cancellationToken);
    }

    private static void AppendHeader(StringBuilder builder, DateTime utcNow)
    {
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("// Generated by Domain.CodeGenerator. Do not edit manually.");
        builder.AppendLine($"// Generated on {utcNow:O} UTC");
        builder.AppendLine();
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine();
        builder.AppendLine("using Domain.Authorization.Models;");
        builder.AppendLine();
        builder.AppendLine("namespace Domain.Authorization.Constants;");
        builder.AppendLine();
        builder.AppendLine("public static class PermissionIds");
        builder.AppendLine("{");
    }

    private static void WriteAllPermissionPaths(StringBuilder builder, IReadOnlyCollection<Permission> permissions)
    {
        builder.AppendLine("    /// <summary>");
        builder.AppendLine("    /// Flat list of all permission paths.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    public static IReadOnlyCollection<string> All { get; } = new string[]");
        builder.AppendLine("    {");

        var distinctPaths = permissions
            .Where(permission => permission.AccessCategory != PermissionAccessCategory.Unspecified)
            .Select(permission => permission.Path)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(path => path, StringComparer.Ordinal);

        foreach (var path in distinctPaths)
        {
            builder.AppendLine($"        \"{EscapeForString(path)}\",");
        }

        builder.AppendLine("    };");
    }

    private static void WriteGlobalScopes(StringBuilder builder)
    {
        builder.AppendLine("    /// <summary>");
        builder.AppendLine("    /// Global permission scope identifiers covering the entire platform.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    public static class Global");
        builder.AppendLine("    {");
        builder.AppendLine("        /// <summary>Global read permission covering every feature.</summary>");
        builder.AppendLine($"        public const string Read = \"{EscapeForString(Permissions.RootReadIdentifier)}\";");
        builder.AppendLine();
        builder.AppendLine("        /// <summary>Global write permission covering every feature.</summary>");
        builder.AppendLine($"        public const string Write = \"{EscapeForString(Permissions.RootWriteIdentifier)}\";");
        builder.AppendLine("    }");
    }

    private static void WritePermissionNode(StringBuilder builder, Permission permission, int indentLevel, IReadOnlyList<string> inheritedParameters)
    {
    var indent = new string(' ', indentLevel * 4);
    var className = ToIdentifier(permission.Identifier);
    var parameterConstants = new List<(string Parameter, string ConstName)>();

        builder.AppendLine();
        builder.AppendLine($"{indent}/// <summary>{EscapeForXml(permission.Description)}</summary>");
        builder.AppendLine($"{indent}public static class {className}");
        builder.AppendLine($"{indent}{{");

        var shouldEmitIdentifier = !permission.HasChildren || permission.AccessCategory != PermissionAccessCategory.Unspecified;
        var shouldEmitParameterConstants = !permission.HasChildren;

        if (shouldEmitIdentifier)
        {
            builder.AppendLine($"{indent}    /// <summary>Permission path for {EscapeForXml(permission.Description)}</summary>");
            builder.AppendLine($"{indent}    public const string Identifier = \"{EscapeForString(permission.Path)}\";");
        }

        var combinedParameters = CombineParameters(inheritedParameters, permission.Parameters);
        var combinedParameterSet = new HashSet<string>(combinedParameters, StringComparer.Ordinal);
        var parameterConstantNames = new HashSet<string>(StringComparer.Ordinal);

        if (shouldEmitParameterConstants && combinedParameters.Count > 0)
        {
            builder.AppendLine();
            foreach (var parameter in combinedParameters)
            {
                var constName = DetermineParameterConstName(parameter, parameterConstantNames);
                parameterConstants.Add((parameter, constName));
                builder.AppendLine($"{indent}    /// <summary>Template parameter '{EscapeForXml(parameter)}' used when materializing this permission.</summary>");
                builder.AppendLine($"{indent}    public const string {constName} = \"{EscapeForString(parameter)}\";");
            }
        }

        var orderedChildren = permission.Permissions
            .OrderBy(child => child.Identifier, StringComparer.Ordinal)
            .ToList();

        Permission? readChild = null;
        Permission? writeChild = null;

        for (var index = orderedChildren.Count - 1; index >= 0; index--)
        {
            var child = orderedChildren[index];
            if (string.Equals(child.Identifier, "_read", StringComparison.Ordinal))
            {
                readChild = child;
                orderedChildren.RemoveAt(index);
            }
            else if (string.Equals(child.Identifier, "_write", StringComparison.Ordinal))
            {
                writeChild = child;
                orderedChildren.RemoveAt(index);
            }
        }

        void AppendAdditionalParameterConstants(Permission childPermission)
        {
            if (!shouldEmitParameterConstants)
            {
                return;
            }

            if (childPermission.Parameters.Length == 0)
            {
                return;
            }

            var additionalParameters = new List<string>();

            foreach (var parameter in childPermission.Parameters)
            {
                if (!combinedParameterSet.Add(parameter))
                {
                    continue;
                }

                additionalParameters.Add(parameter);
            }

            if (additionalParameters.Count == 0)
            {
                return;
            }

            builder.AppendLine();

            foreach (var parameter in additionalParameters)
            {
                var constName = DetermineParameterConstName(parameter, parameterConstantNames);
                parameterConstants.Add((parameter, constName));
                builder.AppendLine($"{indent}    /// <summary>Template parameter '{EscapeForXml(parameter)}' used when materializing this permission.</summary>");
                builder.AppendLine($"{indent}    public const string {constName} = \"{EscapeForString(parameter)}\";");
            }
        }

        if (readChild is not null)
        {
            builder.AppendLine();
            builder.AppendLine($"{indent}    /// <summary>{EscapeForXml(readChild.Description)}</summary>");
            builder.AppendLine($"{indent}    public const string ReadIdentifier = \"{EscapeForString(readChild.Path)}\";");
            AppendAdditionalParameterConstants(readChild);
        }

        if (writeChild is not null)
        {
            builder.AppendLine();
            builder.AppendLine($"{indent}    /// <summary>{EscapeForXml(writeChild.Description)}</summary>");
            builder.AppendLine($"{indent}    public const string WriteIdentifier = \"{EscapeForString(writeChild.Path)}\";");
            AppendAdditionalParameterConstants(writeChild);
        }

        if (shouldEmitIdentifier && parameterConstants.Count > 0)
        {
            builder.AppendLine();
            builder.AppendLine($"{indent}    /// <summary>Creates a parameter builder for {EscapeForXml(permission.Description)}</summary>");
            builder.AppendLine($"{indent}    public static ParameterBuilder CreateBuilder() => new ParameterBuilder();");

            foreach (var (parameterName, constName) in parameterConstants)
            {
                var methodName = "With" + ToParameterIdentifier(parameterName);
                builder.AppendLine();
                builder.AppendLine($"{indent}    public static string {methodName}(string value) => new ParameterBuilder().{methodName}(value).Build();");
            }

            builder.AppendLine();
            builder.AppendLine($"{indent}    private static Permission PermissionDefinition => _permissionDefinition ??= ResolvePermission();");
            builder.AppendLine($"{indent}    private static Permission? _permissionDefinition;");
            builder.AppendLine();
            builder.AppendLine($"{indent}    private static Permission ResolvePermission()");
            builder.AppendLine($"{indent}    {{");
            builder.AppendLine($"{indent}        foreach (var candidate in Permissions.GetAll())");
            builder.AppendLine($"{indent}        {{");
            builder.AppendLine($"{indent}            if (string.Equals(candidate.Path, \"{EscapeForString(permission.Path)}\", StringComparison.Ordinal))");
            builder.AppendLine($"{indent}            {{");
            builder.AppendLine($"{indent}                return candidate;");
            builder.AppendLine($"{indent}            }}");
            builder.AppendLine($"{indent}        }}");
            builder.AppendLine($"{indent}        throw new InvalidOperationException(\"Unable to locate permission definition '{EscapeForString(permission.Path)}'.\");");
            builder.AppendLine($"{indent}    }}");
            builder.AppendLine();
            builder.AppendLine($"{indent}    public sealed class ParameterBuilder");
            builder.AppendLine($"{indent}    {{");
            builder.AppendLine($"{indent}        private readonly Dictionary<string, string?> _values = new Dictionary<string, string?>(StringComparer.Ordinal);");
            builder.AppendLine();
            builder.AppendLine($"{indent}        public ParameterBuilder WithRaw(string parameterName, string? value)");
            builder.AppendLine($"{indent}        {{");
            builder.AppendLine($"{indent}            _values[parameterName] = value;");
            builder.AppendLine($"{indent}            return this;");
            builder.AppendLine($"{indent}        }}");

            foreach (var (parameterName, constName) in parameterConstants)
            {
                var methodName = "With" + ToParameterIdentifier(parameterName);
                builder.AppendLine();
                builder.AppendLine($"{indent}        public ParameterBuilder {methodName}(string value)");
                builder.AppendLine($"{indent}        {{");
                builder.AppendLine($"{indent}            return WithRaw({constName}, value);");
                builder.AppendLine($"{indent}        }}");
            }

            builder.AppendLine();
            builder.AppendLine($"{indent}        public string Build()");
            builder.AppendLine($"{indent}        {{");
            builder.AppendLine($"{indent}            if (_values.Count == 0)");
            builder.AppendLine($"{indent}            {{");
            builder.AppendLine($"{indent}                return Identifier;");
            builder.AppendLine($"{indent}            }}");
            builder.AppendLine();
            builder.AppendLine($"{indent}            return PermissionDefinition.BuildPath(_values);");
            builder.AppendLine($"{indent}        }}");
            builder.AppendLine();
            builder.AppendLine($"{indent}        public override string ToString() => Build();");
            builder.AppendLine($"{indent}    }}");
        }

        if (orderedChildren.Count > 0)
        {
                foreach (var branch in orderedChildren.Where(child => child.HasChildren))
                {
                    WritePermissionNode(builder, branch, indentLevel + 1, combinedParameters);
                }

                foreach (var leaf in orderedChildren.Where(child => !child.HasChildren))
                {
                    WritePermissionNode(builder, leaf, indentLevel + 1, combinedParameters);
                }
        }

        builder.AppendLine($"{indent}}}");
    }

    private static string DetermineParameterConstName(string parameter, HashSet<string> usedNames)
    {
        var baseName = ToParameterIdentifier(parameter) + "Parameter";

        if (usedNames.Add(baseName))
        {
            return baseName;
        }

        var suffix = 2;
        while (true)
        {
            var candidate = baseName + suffix.ToString(CultureInfo.InvariantCulture);
            if (usedNames.Add(candidate))
            {
                return candidate;
            }

            suffix++;
        }
    }

    private static IReadOnlyList<string> CombineParameters(IReadOnlyCollection<string> inherited, IReadOnlyCollection<string> current)
    {
        if (inherited.Count == 0 && current.Count == 0)
        {
            return Array.Empty<string>();
        }

        var result = new List<string>(inherited.Count + current.Count);
        var seen = new HashSet<string>(StringComparer.Ordinal);

        foreach (var parameter in inherited)
        {
            if (seen.Add(parameter))
            {
                result.Add(parameter);
            }
        }

        foreach (var parameter in current)
        {
            if (seen.Add(parameter))
            {
                result.Add(parameter);
            }
        }

        return result;
    }

    private static string ToIdentifier(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return "Value";
        }

        var parts = value.Split(['_', '-', '.'], StringSplitOptions.RemoveEmptyEntries);
        var textInfo = CultureInfo.InvariantCulture.TextInfo;
        var candidate = string.Concat(parts.Select(part => textInfo.ToTitleCase(part.ToLowerInvariant())));

        if (candidate.Length == 0)
        {
            candidate = "Value";
        }

        if (char.IsDigit(candidate[0]))
        {
            candidate = "_" + candidate;
        }

        if (ReservedKeywords.Contains(candidate))
        {
            candidate = "@" + candidate;
        }

        return candidate;
    }

    private static string ToParameterIdentifier(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return "Parameter";
        }

        var normalized = NormalizeParameterValue(value);
        return ToIdentifier(normalized);
    }

    private static string NormalizeParameterValue(string value)
    {
        if (value.IndexOfAny(['_', '-', '.']) >= 0)
        {
            return value;
        }

        var builder = new StringBuilder(value.Length * 2);

        for (var index = 0; index < value.Length; index++)
        {
            var current = value[index];
            if (index > 0 && char.IsUpper(current) && (char.IsLower(value[index - 1]) || char.IsDigit(value[index - 1])))
            {
                builder.Append('_');
            }
            builder.Append(current);
        }

        return builder.ToString();
    }

    private static string EscapeForString(string value) => value
        .Replace("\\", "\\\\")
        .Replace("\"", "\\\"");

    private static string EscapeForXml(string value) => SecurityElement.Escape(value) ?? value;
}
